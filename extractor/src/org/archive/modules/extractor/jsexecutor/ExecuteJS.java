package org.archive.modules.extractor.jsexecutor;

import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.logging.Logger;

import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathFactory;

import org.apache.commons.httpclient.URIException;
import org.archive.crawler.datamodel.CoreAttributeConstants;
import org.archive.crawler.datamodel.CrawlURI;
import org.archive.crawler.extractor.Extractor;
import org.archive.crawler.extractor.ExtractorHTML;
import org.archive.crawler.extractor.Link;
import org.archive.net.UURI;
import org.archive.net.UURIFactory;
import org.lobobrowser.html.UserAgentContext;
import org.lobobrowser.html.domimpl.HTMLAbstractUIElement;
import org.lobobrowser.html.domimpl.HTMLDocumentImpl;
import org.lobobrowser.html.io.WritableLineReader;
import org.lobobrowser.html.js.Window;
import org.lobobrowser.html.renderer.HtmlController;
import org.lobobrowser.html.test.SimpleUserAgentContext;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

/**
 * ExecuteJS adaptes <a href="http://lobobrowser.org/cobra.jsp">Cobra HTML
 * renderer and parser</a>. It has the capability of JavaScript execution, and
 * extract new links generated by JavaScript code.
 * 
 * @author Ping Wang
 * 
 */
public class ExecuteJS extends Extractor implements CoreAttributeConstants {
	private static final long serialVersionUID = 1L;

	private static Logger logger = Logger.getLogger(ExecuteJS.class.getName());

	public ExecuteJS(String name) {
		super(name, "Extract links using embedded JavaScript engine with DOM model");
	}

	@Override
	protected void extract(CrawlURI curi) {
		System.out.println("ExecuteJS: " + curi.getUURI().toString());

		HashSet<String> handledUris = new HashSet<String>();
		HashMap<String, String> contents = null;

		Document document = parse(curi);
		if (document != null) {
			discoverNewLinks(curi, document, handledUris);

			if (shouldSimHTMLEvents()) {
				handleHTMLEvents1(curi, document, handledUris, contents);
			}else{
				handleHTMLEvents(curi, document, handledUris);
			}

			for (Link wref : curi.getOutLinks()) {
				System.out.println(wref.getDestination());
			}
			// uri.setFetchStatus(251);
			logger.info("//END ExecuteJS: " + curi.getUURI().toString());
		}
	}

	// TODO: based on user's configurateion to decide
	protected boolean shouldSimHTMLEvents() {
		return false;
	}

	/**
	 * Parse HTML document, and generate DOM tree, inlined JavaScript code is
	 * executed.
	 * 
	 * @param uri
	 *            uri of current HTML document
	 * @param contents
	 *            contents of current HTML document and resources.
	 * @return
	 */
	public static Document parse(CrawlURI uri) {

		HTMLDocumentImpl document = null;

		try {
			String uriStr = uri.getUURI().getURI();
			System.err.println("[*URI*]" + uriStr);

			UserAgentContext uContext = new SimpleUserAgentContext();
			WritableLineReader wis = new WritableLineReader(
					new InputStreamReader(uri.getHttpRecorder()
							.getRecordedInput().getContentReplayInputStream()));

			document = new HTMLDocumentImpl(uContext, null, wis, uriStr);

			String systemId = uriStr;
			String publicId = systemId;
			HTMLParser parser = new HTMLParser(uContext, document, null,
					publicId, systemId, null);

			parser.parse(wis);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return document;
	}

	/**
	 * Simulate HTML events in an accumulative fashion, and discover new link
	 * after simulation
	 * 
	 * @param uri
	 * @param document
	 * @param handleUris
	 *            new uris which have been discovered.
	 */
	protected void handleHTMLEvents(CrawlURI uri, Document document,
			HashSet<String> handledUris) {
		ArrayList<String> eventsToSim = null;
		if ((eventsToSim = getEventsToSim()) == null)
			return;

		int numOfEventsToSim = eventsToSim.size();
		HTMLEventHandler eventHandler = new HTMLEventHandler(document);

		for (int i = 0; i < numOfEventsToSim; ++i) {
			simHTMLEvent(eventsToSim.get(i), eventHandler);
			discoverNewLinks(uri, document, handledUris);
		}
	}

	/**
	 * Simulate each type of HTML event
	 * 
	 * @param event
	 *            type of HTML event
	 * @param eventHandler
	 */
	protected void simHTMLEvent(String event, HTMLEventHandler eventHandler) {
		if (event.equalsIgnoreCase("onclick")) {
			eventHandler.simMouseClick();
		} else if (event.equalsIgnoreCase("onmouseover")) {
			eventHandler.simMouseOver();
		} else if (event.equalsIgnoreCase("onmouseout")) {
			eventHandler.simMouseOut();
		}
	}

	final public static String HREF_REG_EXPR = "html//a";
	final public static String ONCLICK_REG_EXPR = "//*[@" + "onclick" + "]";

	final public static String ONMOUSEOVER_REG_EXPR = "//*[@" + "onmouseover"
			+ "]";

	final public static String ONMOUSEOUT_REG_EXPR = "//*[@" + "onmouseout"
			+ "]";

	/**
	 * Simulate each HTML event from a fresh start, i.e. a DOM newly generated
	 * by HTML parser.
	 * 
	 * @param uri
	 * @param document
	 * @param handledUris
	 * @param contents
	 */
	protected void handleHTMLEvents1(CrawlURI uri, Document document,
			HashSet<String> handledUris, HashMap<String, String> contents) {
		ArrayList<String> eventsToSim = null;
		if ((eventsToSim = getEventsToSim()) == null)
			return;

		int numOfEventsToSim = eventsToSim.size();

		NodeList nodeList = null;
		Document curDocument;
		int listSize;
		for (int i = 0; i < numOfEventsToSim; ++i) {
			if (eventsToSim.get(i).equalsIgnoreCase("onclick")) {
				// Simulate common onclick event
				nodeList = getNodeList(ONCLICK_REG_EXPR, document);
				if (nodeList != null && (listSize = nodeList.getLength()) != 0) {
					for (int j = 0; j < listSize; ++j) {
						curDocument = parse(uri);
						nodeList = getNodeList(ONCLICK_REG_EXPR, curDocument);
						Element el = (Element) nodeList.item(j);
						onMouseClick(el);
						discoverNewLinks(uri, curDocument, handledUris);
					}
				}

				// Simulate a click on an anchor tag
				nodeList = getNodeList(HREF_REG_EXPR, document);
				if (nodeList != null && (listSize = nodeList.getLength()) != 0) {
					curDocument = parse(uri);
					nodeList = getNodeList(HREF_REG_EXPR, curDocument);
					for (int j = 0; j < listSize; ++j) {
						Element el = (Element) nodeList.item(j);
						onMouseClick(el);
						discoverNewLinks(uri, curDocument, handledUris);
					}
				}

			} else if (eventsToSim.get(i).equalsIgnoreCase("onmouseover")) {
				// Simulate onmouseover event
				nodeList = getNodeList(ONMOUSEOVER_REG_EXPR, document);
				if (nodeList != null && (listSize = nodeList.getLength()) != 0) {
					for (int j = 0; j < listSize; ++j) {
						curDocument = parse(uri);
						nodeList = getNodeList(ONMOUSEOVER_REG_EXPR,
								curDocument);
						Element el = (Element) nodeList.item(j);
						onMouseOver(el);
						discoverNewLinks(uri, curDocument, handledUris);
					}
				}

			} else if (eventsToSim.get(i).equalsIgnoreCase("onmouseout")) {
				// Simulate onmouseout event
				nodeList = getNodeList(ONMOUSEOUT_REG_EXPR, document);
				if (nodeList != null && (listSize = nodeList.getLength()) != 0) {
					for (int j = 0; j < listSize; ++j) {
						curDocument = parse(uri);
						nodeList = getNodeList(ONMOUSEOUT_REG_EXPR, curDocument);
						Element el = (Element) nodeList.item(j);
						onMouseOut(el);
						discoverNewLinks(uri, curDocument, handledUris);
					}
				}
			}
		}
	}

	/*
	 * Document getDocument(CrawlURI uri, HashMap<String, String> contents) {
	 * return parse(uri, contents); }
	 */

	/**
	 * Process onclick event on a specific element
	 * 
	 * @param el
	 */
	public static void onMouseClick(Element el) {
		if (el instanceof HTMLAbstractUIElement) {
			HTMLAbstractUIElement uiElement = (HTMLAbstractUIElement) el;
			HtmlController.getInstance().onMouseClick(uiElement, null, 0, 0);
		}
	}

	/**
	 * Process onmouseover event on a specific element
	 * 
	 * @param el
	 */
	public static void onMouseOver(Element el) {
		if (el instanceof HTMLAbstractUIElement) {
			HTMLAbstractUIElement uiElement = (HTMLAbstractUIElement) el;
			HtmlController.getInstance().onMouseOver(uiElement, null, 0, 0,
					null);
		}
	}

	/**
	 * Process onmouseout event on a specific element
	 * 
	 * @param el
	 */
	public static void onMouseOut(Element el) {
		if (el instanceof HTMLAbstractUIElement) {
			HTMLAbstractUIElement uiElement = (HTMLAbstractUIElement) el;
			HtmlController.getInstance()
					.onMouseOut(uiElement, null, 0, 0, null);
		}
	}

	/**
	 * Discover new links, including anchor and img tags.
	 * 
	 * @param uri
	 *            current uri
	 * @param document
	 *            DOM generated
	 * @param handledUris
	 *            new uris which have been discovered.
	 */
	protected void discoverNewLinks(CrawlURI uri, Document document,
			HashSet<String> handledUris) {

		handleRedirection(uri, document, handledUris);
		extractLinksFromDOM(uri, document, handledUris);
	}

	/**
	 * Check if JS redirection happened, if so, add a new link and mark it as
	 * navigation link not a referrer link
	 * 
	 * @param curi
	 * @param document
	 * @param handledUris
	 */
	protected void handleRedirection(CrawlURI curi, Document document,
			HashSet<String> handledUris) {
		String newUri = null;
		if ((newUri = getJSRedirection((HTMLDocumentImpl) document)) != null) {
			if (handledUris.add(newUri)) {
				addLinkFromString(curi, newUri, "JSRedirection",
						Link.NAVLINK_HOP);
			}
		}
	}

	/**
	 * Get JavaScript redirection
	 * 
	 * @param document
	 * @return uri of JS redirection, return null if no redirection
	 */
	public static String getJSRedirection(HTMLDocumentImpl document) {

		Window window = (Window) document.getDefaultView();
		String locationHref = window.getLocation().getLocationHref();
		if (locationHref != null && !locationHref.equals(document.getURL())) {
			return locationHref;
		}

		return null;
	}

	/**
	 * Find links from a DOM
	 * 
	 * @param uri
	 * @param document
	 * @param handledUris
	 */
	protected void extractLinksFromDOM(CrawlURI uri, Document document,
			HashSet<String> handledUris) {

		extractImgUris(uri, document, handledUris);
		extractAnchorUris(uri, document, handledUris);
	}

	public static CharSequence elementContext(CharSequence element,
			CharSequence attribute) {
		return attribute == null ? "" : element + "/@" + attribute;
	}

	/**
	 * Find image source links
	 * 
	 * @param uri
	 * @param document
	 * @param handledUris
	 */
	private void extractImgUris(CrawlURI uri, Document document,
			HashSet<String> handledUris) {
		NodeList nodeList = getNodeList("html//img", document);

		if (nodeList != null) {
			int size = nodeList.getLength();
			for (int i = 0; i < size; ++i) {
				Element element = (Element) nodeList.item(i);
				String value = element.getAttribute("src");
				if (value != null && handledUris.add(value)) {
					CharSequence context = elementContext("img", "src");
					addLinkFromString(uri, value, context, Link.EMBED_HOP);
				}
			}
		}
	}

	/**
	 * Find anchor href links
	 * 
	 * @param uri
	 * @param document
	 * @param handledUris
	 */
	private void extractAnchorUris(CrawlURI uri, Document document,
			HashSet<String> handledUris) {
		NodeList nodeList = getNodeList("html//a", document);

		if (nodeList != null) {
			int size = nodeList.getLength();
			for (int i = 0; i < size; ++i) {
				Element element = (Element) nodeList.item(i);
				String value = element.getAttribute("href");
				if (value != null && handledUris.add(value)) {
					CharSequence context = elementContext("a", "href");
					addLinkFromString(uri, value, context, Link.NAVLINK_HOP);
				}
			}
		}
	}

	/**
	 * Copied from class ExtractorHTML, made a little modification
	 * 
	 * @param uri
	 * @param value
	 * @param context
	 * @param hop
	 */
	private void addLinkFromString(CrawlURI uri, String value,
			CharSequence context, char hop) {
		try {
			uri.createAndAddLinkRelativeToBase(value, context, hop);
		} catch (URIException e) {
			logUriError(e, uri, value);
		}
	}

	// TODO: Get user's configuration
	private ArrayList<String> getEventsToSim() {
		ArrayList<String> eventsToSim = new ArrayList<String>();
		eventsToSim.add("onmouseover");
		eventsToSim.add("onmouseout");
		eventsToSim.add("onclick");
		return eventsToSim;
	}

	/**
	 * Copied from class ExtractorHTML
	 * 
	 * @param e
	 * @param uri
	 * @param l
	 */
	protected void logUriError(URIException e, CrawlURI uri, CharSequence l) {
		if (e.getReasonCode() == UURIFactory.IGNORED_SCHEME) {
			// don't log those that are intentionally ignored
			return;
		}
//		e.printStackTrace();
		// uriErrors.logUriError(e, uri.getUURI(), l);
	}

	/**
	 * Given an XPath expression, find nodes in a DOM
	 * 
	 * @param evalExp
	 *            an XPath expression
	 * @param document
	 * @return a list of nodes if found
	 */
	public static NodeList getNodeList(String evalExp, Object document) {

		NodeList nodeList = null;
		XPath xpath = XPathFactory.newInstance().newXPath();
		try {
			nodeList = (NodeList) xpath.evaluate(evalExp, document,
					XPathConstants.NODESET);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return nodeList;
	}
}
